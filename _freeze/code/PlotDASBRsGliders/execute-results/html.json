{
  "hash": "324befb5bc77e8918fab4882b44b27a8",
  "result": {
    "markdown": "---\ntitle: \"redo\"\nauthor: \"Kourtney Burger\"\ndate: \"2025-01-15\"\noutput: html_document\neditor_options: \n  markdown: \n    wrap: 72\n    \n---\n\n\n# Load Packages\n\n\n\n\n\n# Clean and Prep Data\n\n## DASBRs\n\nNote: There are too many DASBR points to plot these efficiently so I am\ntrying to to concatenate the data into hourly gps points (taking the\nfirst point from each hour) 1. Load driftwatch functions and GPS\ndatabase\n\n1.  Load driftwatch functions and GPS database\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Load driftwatch functions here - note: line 39 of this code is commented out, only works if full driftwatch directory is saved to this repo\n    source(here('code/driftwatch/DriftWatchFunctions.R'))\n    \n    # Load GPS database, may need to download updated version from driftwatch google drive if new drifts aren't included\n    db <- here('data/GPS/DASBRs/SPOTGPS_Logger.sqlite3')\n    ```\n    :::\n\n\n2.  Select what data you want to plot\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #All CalCurCEAS data\n    DASBR_gps <- getDbDeployment(db)\n    DASBR_gps <- filter(DASBR_gps, grepl('CalCurCEAS_', DriftName))\n    ```\n    :::\n\n\n    For testing, subset the data\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # DASBR_gps <- getDbDeployment(db, drift = c('CalCurCEAS_006', 'CalCurCEAS_007', 'CalCurCEAS_008', 'CalCurCEAS_009', 'CalCurCEAS_010', 'CalCurCEAS_011', 'CalCurCEAS_012', 'CalCurCEAS_013', 'CalCurCEAS_014', 'CalCurCEAS_015'))\n    ```\n    :::\n\n\n3.  Average GPS data - 1 point per drift per hour\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #Subset to only include DriftName, UTC, latitude, and longitude\n    DASBR_gps <- DASBR_gps %>% \n      select(UTC,Latitude,Longitude,DriftName)\n    \n    DASBR_hourly_gps <- DASBR_gps %>%\n      # Convert UTC to POSIXct format\n      mutate(UTC = as.POSIXct(UTC, format = \"%Y-%m-%d %H:%M:%S\")) %>% \n      # \n      mutate(UTC = floor_date(UTC, \"hour\")) %>% \n      # Group by drift and the hour from UTC\n      group_by(DriftName, UTC) %>% \n      # Average the data so there is one point per hour per drift\n      summarize(\n        Latitude = mean(Latitude, na.rm = TRUE), \n        Longitude = mean(Longitude, na.rm = TRUE), \n      )\n    \n    # Change DriftName to general name to match gliders and ship\n    DASBR_hourly_gps <- DASBR_hourly_gps %>% rename(\n      ID = DriftName\n    )\n    ```\n    :::\n\n\n## Gliders\n\n1.  Load and combine glider data\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Load 3 glider gps files\n    Glider_sg639 <- read.csv(here('data/GPS/Gliders/sg639_CalCurCEAS_Sep24_simpleSurfaceGPS.csv'))\n    Glider_sg679 <- read.csv(here('data/GPS/Gliders/sg679_CalCurCEAS_Sep24_simpleSurfaceGPS.csv'))\n    Glider_sg680 <- read.csv(here('data/GPS/Gliders/sg680_CalCurCEAS_Aug24_simpleSurfaceGPS.csv'))\n    \n    # Add ID column to each dataframe\n    Glider_sg639 <- Glider_sg639 %>% \n      mutate(ID = 'sg639')\n    \n    Glider_sg679 <- Glider_sg679 %>% \n      mutate(ID = 'sg679')\n    \n    Glider_sg680 <- Glider_sg680 %>% \n      mutate(ID = 'sg680')\n    \n    # Combine into one dataframe\n    glider_GPS <- bind_rows(Glider_sg639, Glider_sg679, Glider_sg680)\n    ```\n    :::\n\n\n2.  Clean glider data - we do not need to average these because there\n    are fewer points\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Only interested in GPS points at start of dive, remove end of dive points\n    glider_GPS <- glider_GPS %>% \n      filter(label == \"start\")\n    \n    # correct datetime format\n    glider_GPS$dateTime_UTC <- as.POSIXct(glider_GPS$dateTime_UTC, format = \"%d-%b-%Y %H:%M:%S\", tz = \"UTC\")\n    \n    # Subset to only include glider ID, datetime, latitude, and longitude\n    glider_GPS <- glider_GPS %>% \n      select(ID, dateTime_UTC,latitude,longitude)\n    \n    # change column names\n    glider_GPS <- glider_GPS %>% rename(\n      ID = ID,\n      UTC = dateTime_UTC,\n      Latitude = latitude,\n      Longitude = longitude\n    )\n    ```\n    :::\n\n\n## Ship Track\n\nSelene prepped ship track data from DAS files (see [Selene's\ncode](https://github.com/NMFS-PAM-Glider/glider-CalCurCEAS/blob/main/R/shipEffortTrack.R))\n\n\n::: {.cell}\n\n```{.r .cell-code}\nship <- read.csv(here(\"data/GPS/Ship Track/ship_effort.csv\"))\n\n# make sure datetime format is correct\nship$DateTime <- as.POSIXct(ship$DateTime, format = \"%Y-%m-%d %H:%M:%S\", tz = \"UTC\")\n\n# Subset to only include an ID column, datetime, latitude, and longitude\nshipTrack_GPS <- ship %>% \n  select(line_num, DateTime, Lat, Lon)\n\n# add ID column with Ship for all\nshipTrack_GPS <- shipTrack_GPS %>% \n  mutate(ID = \"Ship\")\n\n# change column names\nshipTrack_GPS <- shipTrack_GPS %>% \n  rename(ID = ID,\n         UTC = DateTime,\n         Latitude = Lat,\n         Longitude = Lon,\n         LineNumber = line_num\n         )\n# remove line number for consistency purposes\n# shipTrack_GPS <- shipTrack_GPS %>%\n#   mutate(LineNumber = NULL)\n\n# remove NA rows (2 rows had no time or latitude)\nshipTrack_GPS <- na.omit(shipTrack_GPS)\n```\n:::\n\n\n## Combine DASBRs & Gliders\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Excluding ship track so I can control that layer independently on map\nAllGPS <- bind_rows(DASBR_hourly_gps, glider_GPS)\n```\n:::\n\n\n# Plot Data\n\n## Prep Map Data/Layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert DASBR and glider tracklines to sf object and set a standardized coordinate reference system\nGPS_sf <- st_as_sf(AllGPS, coords = c(\"Longitude\",\"Latitude\"), crs = 4326)\n\n# Convert GPS points to linestrings (NOTE: this excludes time as a variable)\nGPS_sf_lines <- GPS_sf %>%\n  arrange(ID) %>%\n  group_by(ID) %>%\n  summarise(geometry = st_sfc(st_linestring(st_coordinates(geometry)[, 1:2]))) %>%\n  ungroup()\n\n# Convert ship trackline to sf object and set a standardized coordinate reference system\nshipTrack_GPS_sf <- st_as_sf(shipTrack_GPS, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)\n\n\n# Extract the max and min coordinates of the data to set plot limits (NOTE: not tacking ship track into account for bounds)\nbbox <- st_bbox(GPS_sf)\nxlim_vals <- c(bbox[\"xmin\"]-1, bbox[\"xmax\"]+1)\nylim_vals <- c(bbox[\"ymin\"], bbox[\"ymax\"])\n\n\n# Load bathymetric data for the plot limits selected above, +- 1 unit of lat and lon to make map boundaries extend\nbathy <- getNOAA.bathy(lon1 = bbox[\"xmin\"]-1, lon2 = bbox[\"xmax\"]+1, \n                       lat1 = bbox[\"ymin\"]-1, lat2 = bbox[\"ymax\"]+1, \n                       resolution = 1)\n\n# Convert bathymetry data object to a dataframe\nbathy_df <- fortify.bathy(bathy)\n\n# Load coastline and land data and convert it to an sf object\ncoastline_sf <- ne_download(scale = 10, type = 'coastline', category = 'physical', returnclass = \"sf\")\nland <- ne_countries(scale = \"medium\", returnclass = \"sf\")\n# cities ~ borrowed from Taiki's driftwatch code\nPOI <- tibble::tribble(\n    ~Name, ~Latitude, ~Longitude,\n#    \"San Diego\", 32.71068967391705, -117.17147162885448,\n#    \"Santa Barbara\",34.407205041229595, -119.69269808900013,\n#    'Ventura',34.250263795418434, -119.26720606042934,\n#   'Morro Bay',35.36841835524968, -120.86325292077103,\n#    'Monterey Bay',36.604218252060306, -121.89240128825472,\n#    'Santa Cruz',36.96225980624226, -122.00212520928149,\n#    'Half Moon Bay',37.50293801397416, -122.48765584637566,\n    'San Francisco',37.813095434735914, -122.50037485469521,\n#    'Bodega Bay',38.30982199529412, -123.05611099859385,\n#    'Fort Bragg',39.42849849826603, -123.81309923266699,\n#    'Shelter Cove',40.02403071506129, -124.06607534915634,\n    'Eureka',40.806299478998056, -124.1807826182425,\n#    'Crescent City',41.74692081633374, -124.19223894744171,\n    'Point Conception',34.4483491615287, -120.47193766943991,\n#    'Point Arena',38.91093890217707, -123.71170879559632,\n#    'Cape Mendocino', 40.438268949326925, -124.40971460611878\n#    'Coos Bay', 43.371729, -124.216278,\n    'Newport', 44.63205, -124.044233,\n    'Astoria',  46.181591, -123.830038,\n#    'Wesport', 46.885821, -124.100979, \n#    'La Push', 47.902640, -124.602445\n)\nPOI_sf <- st_as_sf(POI, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)\n\n\n# Making sure all the mapping data is set to the same coordinate reference system (WGS84) (redundant for gps data but just making sure)\nGPS_sf_lines <- st_set_crs(GPS_sf_lines, 4326) # GPS data\ncoastline_sf <- st_set_crs(coastline_sf, 4326) # coastline\nland_sf <- st_set_crs(land, 4326) # land\n\n\n# Prep points for adding labels to map. Each drift will be labeled on the first point\nlabel_points <- GPS_sf %>%\n  group_by(ID) %>%\n  slice(1) %>%\n  ungroup()\n\nlabel_points <- label_points %>% # Extract coordinates for labeling\n  mutate(\n    x = st_coordinates(.)[,1],  # Extract the longitude (X)\n    y = st_coordinates(.)[,2]   # Extract the latitude (Y)\n  )\n\n\n# Add new column with shortened ID for mapping\nGPS_sf <- GPS_sf %>%\n  mutate(ID_short = sub(\"CalCurCEAS_(\\\\d+)\", \"D\\\\1\", ID), ID_short = sub(\"^D0+\", \"D\", ID_short))\n\nGPS_sf_lines <- GPS_sf_lines %>% \n  mutate(ID_short = sub(\"CalCurCEAS_(\\\\d+)\", \"D\\\\1\", ID), ID_short = sub(\"^D0+\", \"D\", ID_short))\n\nlabel_points <- label_points %>% \n  mutate(ID_short = sub(\"CalCurCEAS_(\\\\d+)\", \"D\\\\1\", ID), ID_short = sub(\"^D0+\", \"D\", ID_short))\n```\n:::\n\n\n## Static Basemap\n\n### Grouped by ID\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot grouped by ID (i.e. dasbr, glider, ship)\np_ID <- ggplot() +\n  # Add map layer\n  geom_raster(data = bathy_df, aes(x = x, y = y, fill = z)) + # bathy data\n  scale_fill_gradient(low = \"#333333\", high = \"white\") + # change bathy to grey scale\n  geom_sf(data = land_sf) + # land layer\n  geom_sf(data = coastline_sf, color = \"black\", size = 0.5) + # coastline layer\n  geom_sf(data = POI_sf) + # cities\n  geom_text(data = POI, aes(x = Longitude, y = Latitude, label = Name), size = 2, color = \"#333333\", nudge_x = 1) + # add city labels\n  geom_sf(data = shipTrack_GPS_sf, aes(alpha = 0.3, linetype = \"dashed\"), size = 0.5) + # Ship track\n  geom_sf(data = GPS_sf, aes(color = as.factor(ID), group = ID, linetype = \"dashed\"), size = 0.5) + # DASBRs and Gliders\n  coord_sf(xlim = xlim_vals, ylim = ylim_vals) + # correct axis limits to match coordinate bounding box created above\n  \n  # Fix plot labels \n  labs(x = \"Longitude\", y = \"Latitude\", title = \"DASBRs, gliders, & ship tracks\", color = \"ID\") +\n  \n  # Tidy plot\n  guides(\n  # fill = guide_legend(title = \"Depth (m)\"), # adds a depth legend, include and comment out line below if you want this \n  fill = guide_none(), # removes depth legend, comment out line above if you want this\n  color = guide_legend(title = \"Drift ID\"), # changes legend title\n  linetype = \"none\", # removes the linetype legend \n  alpha = \"none\") +  \n  theme(legend.position = \"right\",\n        legend.margin = margin(t = 200), \n        axis.text = element_text(size = 8),\n        axis.title = element_text(size = 14),\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 10)) +\n#  scale_color_viridis_d() + # change color scale \n  theme_minimal() # simplify plot\n\n# save simple static plot\nggsave(here('figs/DASBR_Glider_Ship_SimpleStaticplot.png'), bg = \"white\")\n```\n:::\n\n\n### Grouped by Time\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot grouped by time\np_UTC <- ggplot() +\n  # Add map layer\n  geom_raster(data = bathy_df, aes(x = x, y = y, fill = z)) + # bathy data\n  scale_fill_gradient(low = \"#333333\", high = \"white\") + # change bathy to grey scale\n  geom_sf(data = land_sf) + # land layer\n  geom_sf(data = coastline_sf, color = \"black\", size = 0.5) + # coastline layer\n  geom_sf(data = POI_sf) + # cities\n  geom_text(data = POI, aes(x = Longitude, y = Latitude, label = Name), size = 2, color = \"#333333\", nudge_x = 1) + # add city labels\n  geom_sf(data = shipTrack_GPS_sf, aes(color = UTC, alpha = 0.3, linetype = \"dashed\", size = 0.1), size = 0.1) + # Ship track\n  geom_sf(data = GPS_sf, aes(color = UTC, group = ID, linetype = \"dashed\"), size = 0.5) + # DASBRs and Gliders\n  coord_sf(xlim = xlim_vals, ylim = ylim_vals) + # correct axis limits to match coordinate bounding box created above\n  geom_text(data = label_points, aes(x = x, y = y, label = ID_short), size = 2, color = \"black\", check_overlap = TRUE) +  # label first point\n  \n  # Fix plot labels \n  labs(x = \"Longitude\", y = \"Latitude\", title = \"DASBRs, gliders, & ship tracks\") +\n  \n  # Tidy plot\n  guides(\n  # fill = guide_legend(title = \"Depth (m)\"), # adds a depth legend, include and comment out line below if you want this \n  fill = guide_none(), # removes depth legend, comment out line above if you want this\n  color = guide_colorbar(title = \"Date (UTC)\", barheight = unit(8, \"cm\"), ticks = TRUE), \n  color = guide_legend(title = \"Date (UTC)\"), # changes legend title\n  linetype = \"none\", # removes the linetype legend \n  alpha = \"none\") +  \n  scale_color_datetime(labels = scales::date_format(\"%Y-%m-%d\"), breaks = scales::date_breaks(\"10 days\")) +  # Show breaks every 10 days\n  theme(legend.position = \"right\",\n        legend.margin = margin(t = 200), \n        axis.text = element_text(size = 8),\n        axis.title = element_text(size = 14),\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 10)) +\n  theme_minimal() # simplify plot\n\n# save simple static plot\nggsave(here('figs/DASBR_Glider_Ship_SimpleStaticplot_UTC.png'), bg = \"white\")\n```\n:::\n\n\n## Animated Map\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Animated plot by date\np_UTC + \n  transition_time(UTC) +\n  labs(title = \"Day: {frame_time}\") +\n  shadow_mark(alpha = 0.3, size = 0.5)\n\n# Save animation\n# anim_save(here('figs/300f_ship_tracks_animation.gif'), nframes = 100, width = 384,  height = 1080)\n```\n:::\n\n\n# Oregon zoomed in version\n\n## Prep Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# DASBRs\nDASBR_gps <- getDbDeployment(db, drift = c('CalCurCEAS_006', 'CalCurCEAS_007', 'CalCurCEAS_008', 'CalCurCEAS_009', 'CalCurCEAS_010', 'CalCurCEAS_011', 'CalCurCEAS_012', 'CalCurCEAS_013', 'CalCurCEAS_014', 'CalCurCEAS_015'))\n#Subset to only include DriftName, UTC, latitude, and longitude\nDASBR_gps <- DASBR_gps %>% \n  select(UTC,Latitude,Longitude,DriftName)\n\nDASBR_hourly_gps <- DASBR_gps %>%\n  # Convert UTC to POSIXct format\n  mutate(UTC = as.POSIXct(UTC, format = \"%Y-%m-%d %H:%M:%S\")) %>% \n  # \n  mutate(UTC = floor_date(UTC, \"hour\")) %>% \n  # Group by drift and the hour from UTC\n  group_by(DriftName, UTC) %>% \n  # Average the data so there is one point per hour per drift\n  summarize(\n    Latitude = mean(Latitude, na.rm = TRUE), \n    Longitude = mean(Longitude, na.rm = TRUE), \n  )\n\n# Change DriftName to general name to match gliders and ship\nDASBR_hourly_gps <- DASBR_hourly_gps %>% rename(\n  ID = DriftName\n)\n\n\n\n# Gliders loaded above\n\n\n# Excluding ship track so I can control that layer independently on map\nAllGPS <- bind_rows(DASBR_hourly_gps, glider_GPS)\nGPS_sf <- st_as_sf(AllGPS, coords = c(\"Longitude\",\"Latitude\"), crs = 4326)\n\n# BBox\n# Extract the max and min coordinates of the data to set plot limits (NOTE: not tacking ship track into account for bounds)\nbbox <- st_bbox(GPS_sf)\nxlim_vals <- c(bbox[\"xmin\"]-1, bbox[\"xmax\"]+1)\nylim_vals <- c(bbox[\"ymin\"], bbox[\"ymax\"])\n\n\n# Subset ship track based on coordinate limits\nshipTrack_GPS <- shipTrack_GPS %>%\n  filter(Longitude >= xlim_vals[1] & Longitude <= xlim_vals[2] & \n         Latitude >= ylim_vals[1] & Latitude <= ylim_vals[2]) \nshipTrack_GPS_sf <- st_as_sf(shipTrack_GPS, coords = c(\"Longitude\", \"Latitude\"), crs = 4326)\n```\n:::\n\n\n## Plot Data\n\n### By ID\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  # Add map layer\n  geom_raster(data = bathy_df, aes(x = x, y = y, fill = z)) + # bathy data\n  scale_fill_gradient(low = \"#333333\", high = \"white\") + # change bathy to grey scale\n  geom_sf(data = land_sf) + # land layer\n  geom_sf(data = coastline_sf, color = \"black\", size = 0.5) + # coastline layer\n  geom_sf(data = POI_sf) + # cities\n  geom_text(data = POI, aes(x = Longitude, y = Latitude, label = Name), size = 2, color = \"#333333\", nudge_x = .5) + # add city labels\n  geom_sf(data = shipTrack_GPS_sf, aes(alpha = 0.3, linetype = \"dashed\"), size = 0.5) + # Ship track\n  geom_sf(data = GPS_sf, aes(color = as.factor(ID), group = ID, linetype = \"dashed\"), size = 0.5) + # DASBRs and Gliders\n  coord_sf(xlim = xlim_vals, ylim = ylim_vals) + # correct axis limits to match coordinate bounding box created above\n  \n  # Fix plot labels \n  labs(x = \"Longitude\", y = \"Latitude\", title = \"DASBRs, gliders, & ship tracks\", color = \"ID\") +\n  \n  # Tidy plot\n  guides(\n  # fill = guide_legend(title = \"Depth (m)\"), # adds a depth legend, include and comment out line below if you want this \n  fill = guide_none(), # removes depth legend, comment out line above if you want this\n  color = guide_legend(title = \"Drift ID\"), # changes legend title\n  linetype = \"none\", # removes the linetype legend \n  alpha = \"none\") +  \n  theme(legend.position = \"right\",\n        legend.margin = margin(t = 200), \n        axis.text = element_text(size = 8),\n        axis.title = element_text(size = 14),\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 10)) +\n#  scale_color_viridis_d() + # change color scale \n  theme_minimal() # simplify plot\n\n# save simple static plot\nggsave(here('figs/Oregon_DASBR_Glider_Ship_Staticplot.png'), bg = \"white\")\n```\n:::\n\n\n### By Time\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  # Add map layer\n  geom_raster(data = bathy_df, aes(x = x, y = y, fill = z)) + # bathy data\n  scale_fill_gradient(low = \"#333333\", high = \"white\") + # change bathy to grey scale\n  geom_sf(data = land_sf) + # land layer\n  geom_sf(data = coastline_sf, color = \"black\", size = 0.5) + # coastline layer\n  geom_sf(data = POI_sf) + # cities\n  geom_text(data = POI, aes(x = Longitude, y = Latitude, label = Name), size = 2, color = \"#333333\", nudge_x = .5) + # add city labels\n  geom_sf(data = shipTrack_GPS_sf, aes(color = UTC, alpha = 0.3, linetype = \"dashed\", size = 0.1), size = 0.1) + # Ship track\n  geom_sf(data = GPS_sf, aes(color = UTC, group = ID, linetype = \"dashed\"), size = 0.5) + # DASBRs and Gliders\n  coord_sf(xlim = xlim_vals, ylim = ylim_vals) + # correct axis limits to match coordinate bounding box created above\n  geom_text(data = label_points, aes(x = x, y = y, label = ID_short), size = 2, color = \"black\", check_overlap = TRUE) +  # label first point\n  \n  # Fix plot labels \n  labs(x = \"Longitude\", y = \"Latitude\", title = \"DASBRs, gliders, & ship tracks\") +\n  \n  # Tidy plot\n  guides(\n  # fill = guide_legend(title = \"Depth (m)\"), # adds a depth legend, include and comment out line below if you want this \n  fill = guide_none(), # removes depth legend, comment out line above if you want this\n  color = guide_colorbar(title = \"Date (UTC)\", barheight = unit(8, \"cm\"), ticks = TRUE), \n  color = guide_legend(title = \"Date (UTC)\"), # changes legend title\n  linetype = \"none\", # removes the linetype legend \n  alpha = \"none\") +  \n  scale_color_datetime(labels = scales::date_format(\"%Y-%m-%d\"), breaks = scales::date_breaks(\"10 days\")) +  # Show breaks every 10 days\n  theme(legend.position = \"right\",\n        legend.margin = margin(t = 200), \n        axis.text = element_text(size = 8),\n        axis.title = element_text(size = 14),\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 10)) +\n  theme_minimal() # simplify plot\n\n# save simple static plot\nggsave(here('figs/Oregon_DASBR_Glider_Ship_Staticplot_UTC.png'), bg = \"white\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}